import{S as R,i as C,s as T,w as M,x as P,y as x,E as F,q as L,o as H,B as _,J as z,L as S}from"../chunks/index-f5ab8554.js";import{S as B,a as i}from"../chunks/aframe-master-de904285.js";import{g as D}from"../chunks/gltfStore-c4423433.js";import"../chunks/contourLineStore-53888272.js";import"../chunks/index-bcbe7d6b.js";import"../chunks/NavigationButton-33de9067.js";import"../chunks/navigation-0e6511d1.js";import"../chunks/singletons-d1fb5791.js";import"../chunks/difficultyStore-a47291fd.js";import"../chunks/debugStore-07f85d1c.js";import"../chunks/_commonjsHelpers-56d41998.js";import"../chunks/@vite-plugin-wasm-pack@wasm-15893286.js";function O(p){let c,d;return c=new B({props:{scale:p[0]}}),{c(){M(c.$$.fragment)},l(s){P(c.$$.fragment,s)},m(s,v){x(c,s,v),d=!0},p:F,i(s){d||(L(c.$$.fragment,s),d=!0)},o(s){H(c.$$.fragment,s),d=!1},d(s){_(c,s)}}}function f(p){return p*Math.PI/180}function j(p,c,d){let s;z(p,D,t=>d(1,s=t));let v=[.05,.025,.05];const A=new i.exports.THREE.Vector3(0,0,1);AFRAME.registerComponent("curve-point",{schema:{},init(){this.el.addEventListener("componentchanged",this.changeHandler.bind(this)),this.el.emit("curve-point-change")},changeHandler(t){t.detail.name=="position"&&this.el.emit("curve-point-change")}}),AFRAME.registerComponent("curve",{schema:{type:{type:"string",default:"CatmullRom",oneOf:["CatmullRom","CubicBezier","QuadraticBezier","Line"]},closed:{type:"boolean",default:!1}},init(){this.pathPoints=null,this.curve=null,this.el.addEventListener("curve-point-change",this.update.bind(this))},update(t){if(this.points=Array.from(this.el.querySelectorAll("a-curve-point, [curve-point]")),this.points.length<=1)console.warn("At least 2 curve-points needed to draw a curve"),this.curve=null;else{let e=this.points.map(function(n){return n.x!==void 0&&n.y!==void 0&&n.z!==void 0?n:n.object3D.getWorldPosition(new i.exports.THREE.Vector3)});if(!AFRAME.utils.deepEqual(e,this.pathPoints)||t!=="CustomEvent"&&!AFRAME.utils.deepEqual(this.data,t)){switch(this.curve=null,this.pathPoints=e,this.data.type){case"CubicBezier":if(this.pathPoints.length!=4)throw new Error("The Three constructor of type CubicBezierCurve3 requires 4 points");this.curve=new i.exports.THREE.CubicBezierCurve3(this.pathPoints[0],this.pathPoints[1],this.pathPoints[2],this.pathPoints[3]);break;case"QuadraticBezier":if(this.pathPoints.length!=3)throw new Error("The Three constructor of type QuadraticBezierCurve3 requires 3 points");this.curve=new i.exports.THREE.QuadraticBezierCurve3(this.pathPoints[0],this.pathPoints[1],this.pathPoints[2]);break;case"Line":if(this.pathPoints.length!=2)throw new Error("The Three constructor of type LineCurve3 requires 2 points");this.curve=new i.exports.THREE.LineCurve3(this.pathPoints[0],this.pathPoints[1]);break;case"CatmullRom":this.curve=new i.exports.THREE.CatmullRomCurve3(this.pathPoints);break;case"Spline":this.curve=new i.exports.THREE.SplineCurve3(this.pathPoints);break;default:throw new Error("No Three constructor of type (case sensitive): "+this.data.type+"Curve3")}this.curve.closed=this.data.closed,this.el.emit("curve-updated")}}},remove(){this.el.removeEventListener("curve-point-change",this.update.bind(this))},closestPointInLocalSpace:function(e,n,a,r){if(!this.curve)throw Error("Curve not instantiated yet.");n=n||.1/this.curve.getLength(),r=r||.5,a=a||.5,r/=2;let l=a+r,o=a-r,u=this.curve.getPointAt(l),g=this.curve.getPointAt(o),m=u.distanceTo(e),E=g.distanceTo(e),h=m<E;if(r<n){let w=this.curve.getTangentAt(h?l:o);if(r<n)return{result:h?l:o,location:h?u:g,distance:h?m:E,normal:b(w),tangent:w}}return m<E?this.closestPointInLocalSpace(e,n,l,r):this.closestPointInLocalSpace(e,n,o,r)}});const y=new i.exports.THREE.Quaternion;function b(t){let e=new i.exports.THREE.Vector3(0,1,0);return y.setFromUnitVectors(A,t),e.applyQuaternion(y),e}return AFRAME.registerShader("line",{schema:{color:{default:"#ff0000"}},init(t){this.material=new i.exports.THREE.LineBasicMaterial(t)},update(t){this.material=new i.exports.THREE.LineBasicMaterial(t)}}),AFRAME.registerComponent("draw-curve",{schema:{curve:{type:"selector"}},init(){this.data.curve.addEventListener("curve-updated",this.update.bind(this))},update(){if(this.data.curve&&(this.curve=this.data.curve.components.curve),this.curve&&this.curve.curve){let t=new i.exports.THREE.BufferGeometry().setFromPoints(this.curve.curve.getPoints(this.curve.curve.getPoints().length*10)),e=this.el.getOrCreateObject3D("mesh",i.exports.THREE.Line);lineMaterial=e.material?e.material:new i.exports.THREE.LineBasicMaterial({color:"#ff0000"}),this.el.setObject3D("mesh",new i.exports.THREE.Line(t,lineMaterial))}},remove(){this.data.curve.removeEventListener("curve-updated",this.update.bind(this)),this.el.getObject3D("mesh").geometry=new i.exports.THREE.Geometry}}),AFRAME.registerComponent("clone-along-curve",{schema:{curve:{type:"selector"},spacing:{default:1},rotation:{type:"vec3",default:AFRAME.utils.coordinates.parse("0 0 0")},scale:{type:"vec3",default:AFRAME.utils.coordinates.parse("1 1 1")}},init(){this.el.addEventListener("model-loaded",this.update.bind(this)),this.data.curve.addEventListener("curve-updated",this.update.bind(this))},update(){if(this.remove(),this.data.curve&&(this.curve=this.data.curve.components.curve),!this.el.getObject3D("clones")&&this.curve&&this.curve.curve){let t=this.el.getObject3D("mesh"),e=this.curve.curve.getLength(),a=0,r=this.el.getOrCreateObject3D("clones",i.exports.THREE.Group),l=new i.exports.THREE.Object3D;for(t.scale.set(this.data.scale.x,this.data.scale.y,this.data.scale.z),t.rotation.set(f(this.data.rotation.x),f(this.data.rotation.y),f(this.data.rotation.z)),t.rotation.order="YXZ",l.add(t);a<=e;){let o=l.clone(!0);o.position.copy(this.curve.curve.getPointAt(a/e));const u=this.curve.curve.getTangentAt(a/e).normalize();o.quaternion.setFromUnitVectors(A,u),r.add(o),a+=this.data.spacing}}},remove(){this.curve=null,this.el.getObject3D("clones")&&this.el.removeObject3D("clones")}}),AFRAME.primitives.primitives["a-draw-curve"]||AFRAME.registerPrimitive("a-draw-curve",{defaultComponents:{"draw-curve":{}},mappings:{curveref:"draw-curve.curve"}}),AFRAME.primitives.primitives["a-curve-point"]||AFRAME.registerPrimitive("a-curve-point",{defaultComponents:{"curve-point":{}},mappings:{}}),AFRAME.primitives.primitives["a-curve"]||AFRAME.registerPrimitive("a-curve",{defaultComponents:{curve:{}},mappings:{type:"curve.type"}}),AFRAME.registerComponent("lava-path",{init(){var t;if(console.log("lava path:"),console.log(s.lava_paths),!!((t=s.lava_paths)!=null&&t.length))for(let e=0;e<s.lava_paths.length;e++){const n=s.lava_paths[e],a=document.createElement("a-curve");a.setAttribute("id","track"+e);for(let o=0;o<n.length;o++){const u=n[o],g=u[0],m=u[2],E=u[1],h=document.createElement("a-curve-point");h.setAttribute("position",{x:g/v[0],y:m/v[1],z:E/v[2]}),a.appendChild(h)}this.el.appendChild(a);const r=document.createElement("a-entity");r.setAttribute("clone-along-curve","curve: #track"+e+"; spacing: 1; rotation: 90 0 0;"),r.setAttribute("geometry","primitive:cylinder; height:1; radius:0.4 ;"),r.setAttribute("material","color: orangered; transparency: true; opacity: 0.001");const l=s.lava_paths.length*2e3;r.setAttribute("animation","property: material.opacity; to: 1; dur: 2000; loop: false; delay: "+(l-e*2e3)+";"),this.el.appendChild(r)}}}),S(()=>{delete AFRAME.components["curve-point"],delete AFRAME.components.curve,delete AFRAME.components["draw-curve"],delete AFRAME.components["lava-path"],delete AFRAME.components["clone-along-curve"],delete AFRAME.shaders.line}),[v]}class Y extends R{constructor(c){super(),C(this,c,j,O,T,{})}}export{Y as default};
