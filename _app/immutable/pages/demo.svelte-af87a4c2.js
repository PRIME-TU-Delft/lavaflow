import{S as x,i as M,s as P,w as L,x as _,y as F,E as H,q as z,o as S,B,J as T,v as D,L as O,M as j}from"../chunks/index-12998d59.js";import{S as q,a as r,h as k,b as $}from"../chunks/aframe-master-38d9b121.js";import{c as R,g as f}from"../chunks/contourLineStore-3828d678.js";import"../chunks/NavigationButton-22a7797a.js";import"../chunks/Button-1b490879.js";import"../chunks/navigation-0e6511d1.js";import"../chunks/singletons-d1fb5791.js";import"../chunks/debugStore-08e1510f.js";import"../chunks/index-d282005e.js";import"../chunks/_commonjsHelpers-56d41998.js";function Q(d){let c,p;return c=new q({}),{c(){L(c.$$.fragment)},l(i){_(c.$$.fragment,i)},m(i,v){F(c,i,v),p=!0},p:H,i(i){p||(z(c.$$.fragment,i),p=!0)},o(i){S(c.$$.fragment,i),p=!1},d(i){B(c,i)}}}function A(d){return d*Math.PI/180}function V(d,c,p){let i,v;T(d,f,e=>p(1,i=e)),T(d,R,e=>p(2,v=e));const y=new r.exports.THREE.Vector3(0,0,1);AFRAME.registerComponent("curve-point",{schema:{},init(){this.el.addEventListener("componentchanged",this.changeHandler.bind(this)),this.el.emit("curve-point-change")},changeHandler(e){e.detail.name=="position"&&this.el.emit("curve-point-change")}}),AFRAME.registerComponent("curve",{schema:{type:{type:"string",default:"CatmullRom",oneOf:["CatmullRom","CubicBezier","QuadraticBezier","Line"]},closed:{type:"boolean",default:!1}},init(){this.pathPoints=null,this.curve=null,this.el.addEventListener("curve-point-change",this.update.bind(this))},update(e){if(this.points=Array.from(this.el.querySelectorAll("a-curve-point, [curve-point]")),this.points.length<=1)console.warn("At least 2 curve-points needed to draw a curve"),this.curve=null;else{let t=this.points.map(function(a){return a.x!==void 0&&a.y!==void 0&&a.z!==void 0?a:a.object3D.getWorldPosition(new r.exports.THREE.Vector3)});if(!AFRAME.utils.deepEqual(t,this.pathPoints)||e!=="CustomEvent"&&!AFRAME.utils.deepEqual(this.data,e)){switch(this.curve=null,this.pathPoints=t,this.data.type){case"CubicBezier":if(this.pathPoints.length!=4)throw new Error("The Three constructor of type CubicBezierCurve3 requires 4 points");this.curve=new r.exports.THREE.CubicBezierCurve3(this.pathPoints[0],this.pathPoints[1],this.pathPoints[2],this.pathPoints[3]);break;case"QuadraticBezier":if(this.pathPoints.length!=3)throw new Error("The Three constructor of type QuadraticBezierCurve3 requires 3 points");this.curve=new r.exports.THREE.QuadraticBezierCurve3(this.pathPoints[0],this.pathPoints[1],this.pathPoints[2]);break;case"Line":if(this.pathPoints.length!=2)throw new Error("The Three constructor of type LineCurve3 requires 2 points");this.curve=new r.exports.THREE.LineCurve3(this.pathPoints[0],this.pathPoints[1]);break;case"CatmullRom":this.curve=new r.exports.THREE.CatmullRomCurve3(this.pathPoints);break;case"Spline":this.curve=new r.exports.THREE.SplineCurve3(this.pathPoints);break;default:throw new Error("No Three constructor of type (case sensitive): "+this.data.type+"Curve3")}this.curve.closed=this.data.closed,this.el.emit("curve-updated")}}},remove(){this.el.removeEventListener("curve-point-change",this.update.bind(this))},closestPointInLocalSpace:function(t,a,n,s){if(!this.curve)throw Error("Curve not instantiated yet.");a=a||.1/this.curve.getLength(),s=s||.5,n=n||.5,s/=2;let l=n+s,o=n-s,h=this.curve.getPointAt(l),g=this.curve.getPointAt(o),m=h.distanceTo(t),E=g.distanceTo(t),u=m<E;if(s<a){let w=this.curve.getTangentAt(u?l:o);if(s<a)return{result:u?l:o,location:u?h:g,distance:u?m:E,normal:C(w),tangent:w}}return m<E?this.closestPointInLocalSpace(t,a,l,s):this.closestPointInLocalSpace(t,a,o,s)}});const b=new r.exports.THREE.Quaternion;function C(e){let t=new r.exports.THREE.Vector3(0,1,0);return b.setFromUnitVectors(y,e),t.applyQuaternion(b),t}return AFRAME.registerShader("line",{schema:{color:{default:"#ff0000"}},init(e){this.material=new r.exports.THREE.LineBasicMaterial(e)},update(e){this.material=new r.exports.THREE.LineBasicMaterial(e)}}),AFRAME.registerComponent("draw-curve",{schema:{curve:{type:"selector"}},init(){this.data.curve.addEventListener("curve-updated",this.update.bind(this))},update(){if(this.data.curve&&(this.curve=this.data.curve.components.curve),this.curve&&this.curve.curve){let e=new r.exports.THREE.BufferGeometry().setFromPoints(this.curve.curve.getPoints(this.curve.curve.getPoints().length*10)),t=this.el.getOrCreateObject3D("mesh",r.exports.THREE.Line);lineMaterial=t.material?t.material:new r.exports.THREE.LineBasicMaterial({color:"#ff0000"}),this.el.setObject3D("mesh",new r.exports.THREE.Line(e,lineMaterial))}},remove(){this.data.curve.removeEventListener("curve-updated",this.update.bind(this)),this.el.getObject3D("mesh").geometry=new r.exports.THREE.Geometry}}),AFRAME.registerComponent("clone-along-curve",{schema:{curve:{type:"selector"},spacing:{default:1},rotation:{type:"vec3",default:AFRAME.utils.coordinates.parse("0 0 0")},scale:{type:"vec3",default:AFRAME.utils.coordinates.parse("1 1 1")}},init(){this.el.addEventListener("model-loaded",this.update.bind(this)),this.data.curve.addEventListener("curve-updated",this.update.bind(this))},update(){if(this.remove(),this.data.curve&&(this.curve=this.data.curve.components.curve),!this.el.getObject3D("clones")&&this.curve&&this.curve.curve){let e=this.el.getObject3D("mesh"),t=this.curve.curve.getLength(),n=0,s=this.el.getOrCreateObject3D("clones",r.exports.THREE.Group),l=new r.exports.THREE.Object3D;for(e.scale.set(this.data.scale.x,this.data.scale.y,this.data.scale.z),e.rotation.set(A(this.data.rotation.x),A(this.data.rotation.y),A(this.data.rotation.z)),e.rotation.order="YXZ",l.add(e);n<=t;){let o=l.clone(!0);o.position.copy(this.curve.curve.getPointAt(n/t));const h=this.curve.curve.getTangentAt(n/t).normalize();o.quaternion.setFromUnitVectors(y,h),s.add(o),n+=this.data.spacing}}},remove(){this.curve=null,this.el.getObject3D("clones")&&this.el.removeObject3D("clones")}}),AFRAME.registerComponent("lava-path",{init(){var e;if(console.log("lava path:"),console.log(i.lava_paths),!!((e=i.lava_paths)!=null&&e.length))for(let t=0;t<i.lava_paths.length;t++){const a=i.lava_paths[t],n=document.createElement("a-entity");n.setAttribute("a-curve",""),n.setAttribute("id","track"+t);for(let o=0;o<a.length;o++){const h=a[o],g=h[0],m=h[1],E=h[2],u=document.createElement("a-entity");u.setAttribute("a-curve-point",""),u.setAttribute("position",{x:g,y:E,z:m}),n.appendChild(u)}this.el.appendChild(n);const s=document.createElement("a-entity");s.setAttribute("clone-along-curve","curve: #track"+t+"; spacing: 0.035; rotation: 90 0 0;"),s.setAttribute("geometry","primitive:cylinder; height:0.04; radius:0.5 ;"),s.setAttribute("material","color: orangered; transparency: true; opacity: 0.001");const l=i.lava_paths.length*2e3;s.setAttribute("animation","property: material.opacity; to: 1; dur: 2000; loop: false; delay: "+(l-t*2e3)+";"),this.el.appendChild(s)}}}),D(async()=>{i||(v||R.set({curves:k,hierarchy:$,size:{width:850,height:950}}),await f.setup(v),f.build(),console.warn("gltf is loaded from hardcoded data")),i.lava_paths||O(f,i.lava_paths=[[[4,4,7],[1,1,3],[4,2,2],[3,3,-1]],[[1,1,3],[0,-2,-4],[1,1,-2],[1,2,-1],[2,2,0]],[[1,1,-2],[1,4,-2],[12,1,-1]]],i)}),j(()=>{delete AFRAME.components["curve-point"],delete AFRAME.components.curve,delete AFRAME.components["draw-curve"],delete AFRAME.components["lava-path"],delete AFRAME.components["clone-along-curve"],delete AFRAME.shaders.line}),[]}class ee extends x{constructor(c){super(),M(this,c,V,Q,P,{})}}export{ee as default};
