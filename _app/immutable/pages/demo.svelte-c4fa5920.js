import{S as T,i as P,s as M,w as L,x as F,y as _,E as H,q as z,o as S,B,J as b,v as D,L as O}from"../chunks/index-dda06473.js";import{S as j,h as q,a as x}from"../chunks/SceneViewer-038c7c59.js";import{c as R}from"../chunks/contourLineStore-46b1aab0.js";import{g as E}from"../chunks/gltfStore-2d4a80aa.js";import"../chunks/NavigationButton-a082e38f.js";import"../chunks/Button-cb6e53d7.js";import"../chunks/navigation-0e6511d1.js";import"../chunks/singletons-d1fb5791.js";import"../chunks/debugStore-16c185c0.js";import"../chunks/index-f56ba691.js";function k(p){let o,h;return o=new j({}),{c(){L(o.$$.fragment)},l(i){F(o.$$.fragment,i)},m(i,d){_(o,i,d),h=!0},p:H,i(i){h||(z(o.$$.fragment,i),h=!0)},o(i){S(o.$$.fragment,i),h=!1},d(i){B(o,i)}}}function f(p){return p*Math.PI/180}function $(p,o,h){let i,d;b(p,E,e=>h(1,i=e)),b(p,R,e=>h(2,d=e));const A=new THREE.Vector3(0,0,1);AFRAME.registerComponent("curve-point",{schema:{},init(){this.el.addEventListener("componentchanged",this.changeHandler.bind(this)),this.el.emit("curve-point-change")},changeHandler(e){e.detail.name=="position"&&this.el.emit("curve-point-change")}}),AFRAME.registerComponent("curve",{schema:{type:{type:"string",default:"CatmullRom",oneOf:["CatmullRom","CubicBezier","QuadraticBezier","Line"]},closed:{type:"boolean",default:!1}},init(){this.pathPoints=null,this.curve=null,this.el.addEventListener("curve-point-change",this.update.bind(this))},update(e){if(this.points=Array.from(this.el.querySelectorAll("a-curve-point, [curve-point]")),this.points.length<=1)console.warn("At least 2 curve-points needed to draw a curve"),this.curve=null;else{let t=this.points.map(function(a){return a.x!==void 0&&a.y!==void 0&&a.z!==void 0?a:a.object3D.getWorldPosition(new THREE.Vector3)});if(!AFRAME.utils.deepEqual(t,this.pathPoints)||e!=="CustomEvent"&&!AFRAME.utils.deepEqual(this.data,e)){switch(this.curve=null,this.pathPoints=t,this.data.type){case"CubicBezier":if(this.pathPoints.length!=4)throw new Error("The Three constructor of type CubicBezierCurve3 requires 4 points");this.curve=new THREE.CubicBezierCurve3(this.pathPoints[0],this.pathPoints[1],this.pathPoints[2],this.pathPoints[3]);break;case"QuadraticBezier":if(this.pathPoints.length!=3)throw new Error("The Three constructor of type QuadraticBezierCurve3 requires 3 points");this.curve=new THREE.QuadraticBezierCurve3(this.pathPoints[0],this.pathPoints[1],this.pathPoints[2]);break;case"Line":if(this.pathPoints.length!=2)throw new Error("The Three constructor of type LineCurve3 requires 2 points");this.curve=new THREE.LineCurve3(this.pathPoints[0],this.pathPoints[1]);break;case"CatmullRom":this.curve=new THREE.CatmullRomCurve3(this.pathPoints);break;case"Spline":this.curve=new THREE.SplineCurve3(this.pathPoints);break;default:throw new Error("No Three constructor of type (case sensitive): "+this.data.type+"Curve3")}this.curve.closed=this.data.closed,this.el.emit("curve-updated")}}},remove(){this.el.removeEventListener("curve-point-change",this.update.bind(this))},closestPointInLocalSpace:function(t,a,n,r){if(!this.curve)throw Error("Curve not instantiated yet.");a=a||.1/this.curve.getLength(),r=r||.5,n=n||.5,r/=2;let c=n+r,s=n-r,l=this.curve.getPointAt(c),g=this.curve.getPointAt(s),v=l.distanceTo(t),m=g.distanceTo(t),u=v<m;if(r<a){let w=this.curve.getTangentAt(u?c:s);if(r<a)return{result:u?c:s,location:u?l:g,distance:u?v:m,normal:C(w),tangent:w}}return v<m?this.closestPointInLocalSpace(t,a,c,r):this.closestPointInLocalSpace(t,a,s,r)}});const y=new THREE.Quaternion;function C(e){let t=new THREE.Vector3(0,1,0);return y.setFromUnitVectors(A,e),t.applyQuaternion(y),t}return AFRAME.registerShader("line",{schema:{color:{default:"#ff0000"}},init(e){this.material=new THREE.LineBasicMaterial(e)},update(e){this.material=new THREE.LineBasicMaterial(e)}}),AFRAME.registerComponent("draw-curve",{schema:{curve:{type:"selector"}},init(){this.data.curve.addEventListener("curve-updated",this.update.bind(this))},update(){if(this.data.curve&&(this.curve=this.data.curve.components.curve),this.curve&&this.curve.curve){let e=new THREE.BufferGeometry().setFromPoints(this.curve.curve.getPoints(this.curve.curve.getPoints().length*10)),t=this.el.getOrCreateObject3D("mesh",THREE.Line);lineMaterial=t.material?t.material:new THREE.LineBasicMaterial({color:"#ff0000"}),this.el.setObject3D("mesh",new THREE.Line(e,lineMaterial))}},remove(){this.data.curve.removeEventListener("curve-updated",this.update.bind(this)),this.el.getObject3D("mesh").geometry=new THREE.Geometry}}),AFRAME.registerComponent("clone-along-curve",{schema:{curve:{type:"selector"},spacing:{default:1},rotation:{type:"vec3",default:AFRAME.utils.coordinates.parse("0 0 0")},scale:{type:"vec3",default:AFRAME.utils.coordinates.parse("1 1 1")}},init(){this.el.addEventListener("model-loaded",this.update.bind(this)),this.data.curve.addEventListener("curve-updated",this.update.bind(this))},update(){if(this.remove(),this.data.curve&&(this.curve=this.data.curve.components.curve),!this.el.getObject3D("clones")&&this.curve&&this.curve.curve){let e=this.el.getObject3D("mesh"),t=this.curve.curve.getLength(),n=0,r=this.el.getOrCreateObject3D("clones",THREE.Group),c=new THREE.Object3D;for(e.scale.set(this.data.scale.x,this.data.scale.y,this.data.scale.z),e.rotation.set(f(this.data.rotation.x),f(this.data.rotation.y),f(this.data.rotation.z)),e.rotation.order="YXZ",c.add(e);n<=t;){let s=c.clone(!0);s.position.copy(this.curve.curve.getPointAt(n/t));const l=this.curve.curve.getTangentAt(n/t).normalize();s.quaternion.setFromUnitVectors(A,l),r.add(s),n+=this.data.spacing}}},remove(){this.curve=null,this.el.getObject3D("clones")&&this.el.removeObject3D("clones")}}),AFRAME.registerPrimitive("a-draw-curve",{defaultComponents:{"draw-curve":{}},mappings:{curveref:"draw-curve.curve"}}),AFRAME.registerPrimitive("a-curve-point",{defaultComponents:{"curve-point":{}},mappings:{}}),AFRAME.registerPrimitive("a-curve",{defaultComponents:{curve:{}},mappings:{type:"curve.type"}}),AFRAME.registerComponent("lava-path",{init(){var e;if(console.log("lava path:"),console.log(i.lava_paths),!!((e=i.lava_paths)!=null&&e.length))for(let t=0;t<i.lava_paths.length;t++){const a=i.lava_paths[t],n=document.createElement("a-curve");n.setAttribute("id","track"+t);for(let s=0;s<a.length;s++){const l=a[s],g=l[0],v=l[1],m=l[2],u=document.createElement("a-curve-point");u.setAttribute("position",{x:g,y:m,z:v}),n.appendChild(u)}this.el.appendChild(n);const r=document.createElement("a-entity");r.setAttribute("clone-along-curve","curve: #track"+t+"; spacing: 0.035; rotation: 90 0 0;"),r.setAttribute("geometry","primitive:cylinder; height:0.04; radius:0.5 ;"),r.setAttribute("material","color: orangered; transparency: true; opacity: 0.001");const c=i.lava_paths.length*2e3;r.setAttribute("animation","property: material.opacity; to: 1; dur: 2000; loop: false; delay: "+(c-t*2e3)+";"),this.el.appendChild(r)}}}),D(async()=>{i||(d||R.set({curves:q,hierarchy:x,size:{width:850,height:950}}),await E.setup(d),E.build(),console.warn("gltf is loaded from hardcoded data",i)),i.lava_paths||O(E,i.lava_paths=[[[4,4,7],[1,1,3],[4,2,2],[3,3,-1]],[[1,1,3],[0,-2,-4],[1,1,-2],[1,2,-1],[2,2,0]],[[1,1,-2],[1,4,-2],[12,1,-1]]],i)}),onDestroy(()=>{delete AFRAME.components["curve-point"],delete AFRAME.components.curve,delete AFRAME.components["draw-curve"],delete AFRAME.components["lava-path"],delete AFRAME.components["clone-along-curve"],delete AFRAME.shaders.line}),[]}class Z extends T{constructor(o){super(),P(this,o,$,k,M,{})}}export{Z as default};
