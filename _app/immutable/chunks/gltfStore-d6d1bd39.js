import{w as d}from"./index-ca69d11e.js";import{c as m,t as f}from"./contourLineStore-67ef1863.js";import{d as g}from"./difficultyStore-0791473c.js";import{d as w}from"./debugStore-b63444ef.js";import{i as y,O as b,M as v,S,a as x,b as M,c as L,L as z}from"./@vite-plugin-wasm-pack@wasm-9c455baf.js";import{a3 as c}from"./index-e50d45aa.js";class A{constructor(a,e,l,p,i,t,r,o,s,h,_){this.tree=a,this.rows=e,this.columns=l,this.width=p,this.height=i,this.curve_point_separation=t,this.svc_distance=r,this.catmull_clark_iterations=o,this.lava_path_length=s,this.lava_path_fork_val=h,this.smoothing_operations=_}apply_to_api(a){a.base(this.tree,this.curve_point_separation),a.set_basic_parameters(this.rows,this.columns,this.width,this.height),a.set_svc_parameters(this.svc_distance),a.set_catmull_clark_parameters(this.catmull_clark_iterations),a.set_lava_path_parameters(this.lava_path_length,this.lava_path_fork_val);for(const e of this.smoothing_operations)e.apply_to_api(a)}}function j(n){return n*(180/Math.PI)}function O(n){let a=n.altitude;return a+=1*n.gradient.map(e=>Math.abs(e)).reduce((e,l)=>Math.max(e,l)),a*1.07}function u(n){const a=new Blob([n],{type:"application/json"});return URL.createObjectURL(a)}function G(){const{subscribe:n,set:a}=d();let e,l,p=!1,i;return{subscribe:n,set:a,setup:async(t,r)=>{p||(await y(),p=!0),l=t.size;const o=new b({pixels_per_curve:t.curves,parent_relations:t.hierarchy});e=new v,new A(o,45,45,t.size.width,t.size.height,5,Math.max(t.size.width,t.size.height)/(45*1.5),1,20,r,[new S(0,.3,5,1,!1),new x(.7,3,5,!1),new M(.25,!0),new L(1,8,1,!1)]).apply_to_api(e)},build:t=>{let r=performance.now();i=e.build().to_js();let o=performance.now();c(w)&&alert(`Generated GLTF model in ${o-r}ms`),i.gltf_url=u(i.gltf),i.lava_gltf_url=u(i.lava_gltf),i.craters=i.craters.map(s=>[s[0]*t.size.width/100,s[1]*t.size.height/100]),m.set(i.craters),a(i)},getAlitituteAndGradient:(t,r=!1)=>{if(!e)return{x:0,y:0,altitude:0,gradient:[0,0,0]};let[o,s]=[t.x,t.y];r||(o=t.x/l.width*100,s=t.y/l.height*100);const h=e.get_altitude_and_gradient_for_point(o,s).to_js();return h.gradient.map(_=>j(_)),h.altitude=O(h),h},computePlayerPoints:t=>{if(!e)return 0;const{width:r,height:o}=l;return e.compute_player_points(new z({lava_paths:i.lava_paths,turbines:c(f).map(s=>[s.x/r*100,s.y/o*100]),max_lava_distance:c(g).max_lava_distance,max_points_total:t}))}}}const C=G();export{C as g};
